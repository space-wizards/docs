```admonish warning "В процессе"
Эта страница находится в стадии разработки! Некоторая информация может быть неполной или неактуальной.
```

# Git для разработчика СС14

Если вы когда-нибудь смотрели халтурно написанное руководство по Git'у или открывали один из множества невероятно раздутых современных графических интерфейсов git'а, таких как GitKraken, вы, вероятно, понимаете, что Git может быть *очень запутанным*. Цель этого руководства - дать вам только ту информацию, которая необходима для правильной разработки для SS14, и предоставить вам ресурсы, чтобы узнать больше, если это необходимо.

Здесь немного ресурсов для изучения гита:
- [Онлайн книга от разработчиков Гита](https://git-scm.com/book/en/v2), очень полезная вещь для начинающих, которая может помочь новичкам.
- [Руководство по Git от Atlassian](https://www.atlassian.com/git/tutorials/setting-up-a-repository). Хорошие гайды для более продвинутых пользователей
- [Ёбанный Git!!!](https://ohshitgit.com/ru), список решений распространенных проблем с git в веселом формате. Может пригодиться.
- [Learn Git Branching](https://learngitbranching.js.org/?locale=ru_RU). Этот курс интерактивный и очень подробный, к его концу вы **выучите Git**. Рекомендуется, если вы уже не новичок но и не профи в Git.

## 1. Настройка самого Гита

```admonish danger "НЕ ИСПОЛЬЗУЙТЕ GITKRAKEN"
Ради всех богов, хостов и сисадминов, не устанавливайте GitKraken или GitHub Desktop. Я не испытывал ничего, кроме бесконечной боли, пытаясь помочь людям, использующим их. Я знаю, что GitKraken выглядит профессионально, а GH Desktop - красиво и просто, но, пожалуйста, не используйте их, если вы не знаете, что делаете.
```

Если вы следовали нашему руководству по **настройке среды разработки**, то, вероятно, у вас уже установлен Git. Если нет, перейдите на [их сайт](https://git-scm.org) и установите его прямо сейчас. Это позволит установить сам Git, а также Git Bash (если вы выберете эту опцию) - один из многих способов использования Git. 

Если вы работаете на Линуксе, то, скорее всего, будете использовать Git через терминал или выбранную вами IDE, и, скорее всего, он у вас уже установлен.

Я настоятельно рекомендую хотя бы попробовать Git Bash, но есть и более дружелюбные альтернативы, которые я также покажу здесь:

- [TortoiseGit](https://tortoisegit.org/) -- старый, но хороший графический визуализатор Git, который отображает информацию в проводнике и делает базовые вещи более простыми.
- [SmartGit](https://www.syntevo.com/smartgit/) -- полнофункциональный графический интерфейс Git, хорошо настраиваемый и простой в использовании.

После того как я написал этот гайд я попробовал еще пару вариантов, и среди них есть и другие очень, очень хорошие программы:

- [Fork](https://git-fork.com/) -- быстрый и чрезвычайно эргономичный графический интерфейс, мой личный фаворит. «Платная», но она такая же „небесплатная“ как WinRAR, так что по сути она бесплатная.
- [Sublime Merge](https://www.sublimemerge.com/) -- очень похож на Fork, выглядит и ощущается отлично, и я получал много рекомендаций по его использованию, хотя и не использовал его так много.

Большинство IDE имеют ту или иную форму интеграции с Git. Интеграция Гита [JetBrains Rider](https://www.jetbrains.com/rider/) действительно хороша (и я лично рекомендую Rider для всего, что связано с разработкой в 14 станции). Я не рекомендую Git в Visual Studio, потому что он... не особо хорош

Пока вы здесь, установите `Python 3.7+`, если у вас его еще нет. Вы можете сделать это [здесь](https://www.python.org/) для Windows и Mac, а если вы на Linux, то у вас почти наверняка уже установлен Python. Если нет, разберись сам, тупой придурок.

<hr>

```admonish danger "Сохранность Email и Имени"
Когда вы [настраиваете свои `user.name` и `user.email`](https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup#_your_identity), знайте, что они будут публично отображаться во всех создаваемых вами коммитах. Если вы хотите сохранить конфиденциальность своей информации, вы можете установить `user.name` на ваше имя пользователя вместо вашего настоящего имени, а `user.email` на тот, который предоставляет GitHub, когда в [GitHub Email Settings](https://github.com/settings/emails#primary_email_select_label) установлен флажок [`Keep my email addresses private`](https://github.com/settings/emails#toggle_visibility).
```

Теперь, когда у вас установлен Git, я рекомендую вам сначала немного почитать о его основах и познакомиться с любым git-клиентом, с которым вы работаете, будь то командная строка (Git Bash) или что-то другое.

Мы рассмотрим процесс создания окружения в Git для Space Station 14, чтобы вы могли **внести свой код через pull request, создать собственную кодовую базу** или просто **посмотреть историю проекта**.

### 1.1 Почему мы вообще используем Git?

Git - это **программа контроля версий**. По сути, это простой способ отслеживать изменения в коде и управлять этими изменениями без головной боли. Это бесценный инструмент для разработки программного обеспечения, потому что он позволяет легко вносить новые изменения, просматривать различные изменения, видеть, кто внес изменения, и т. д. без необходимости координировать и табулировать все самостоятельно.

GitHub - это онлайн-сервис, на котором размещаются Git **репозитории** (кодовые базы) для удобства совместной работы. Он идеально подходит для такой кодовой базы, как SS14, с большим количеством участников и большой историей. Это также означает, что у нас *открытый код* - любой может зайти на наш GitHub и скачать его!

## 2. Настройка репозитория

Как я уже говорил, репозиторий - это просто кодовая база. Репозитории содержат несколько **ветвей**, а эти ветви содержат различные **коммиты**. Вы, возможно, слышали об этих двух понятиях - я расскажу о них подробнее позже.

**Удалённый** репозиторий - это просто репозиторий, который находится на серверах GitHub. То что он называется удалённым не означает что его выкинули! **Локальный** репозиторий - это тот, который находится на вашем компьютере.

### 2.1 Создание своего удалённого репозитория

Во-первых, давайте создадим наш собственный удаленный репозиторий Space Station 14. Для этого, конечно, вам понадобится учетная запись на GitHub. "Форк"(Fork) таким образом просто означает, что вы копируете всю историю репозитория и изменения в свой собственный удаленный репозиторий, чтобы вы могли свободно вносить изменения в код.

Ваш удаленный репозиторий не будет автоматически синхронизироваться с изменениями из оригинального репозитория SS14 - вам придется делать это самостоятельно, а как это делать я расскажу чуть позже.

Перейдите в [репозиторий Space Station 14](https://github.com/space-wizards/space-station-14) и нажмите на кнопочку которая помечена на скриншоте:
![](https://i.imgur.com/lAHNHdD.png)

Там вас спросят, где сделать форк и как его назвать - просто зайдите в свой обычный аккаунт и назовите его как угодно! Я бы выбрал `space-station-14`, если вы просто хотите помочь в разработке.

### 2.2 Создание своего локального репозитория

Теперь нам нужно загрузить наш удаленный репозиторий на наш компьютер (это называется **клонирование**), чтобы мы могли добавить ~~20 пар клоунских ботинок в каждый шкафчик~~ некоторые изменения в нем. Технически вы *можете* изменить удаленный репозиторий (на GitHub есть несколько хороших инструментов), но наличие его на вашем компьютере означает, что вы используете IDE вроде Visual Studio или Rider для сборки игры и запуска тестов, а также для удобной работы с Git.
Для каждого шага будут приведены скриншоты и инструкции для Git Bash, SmartGit и TortoiseGit под Windows.

Перейдите в то место на вашем компьютере, где вы хотите разместить локальный репозиторий, и:
<details><summary>TortoiseGit</summary>
<p>

Щелкните правой кнопкой мыши, чтобы увидеть контекстное меню TortoiseGit:

![](https://i.imgur.com/QGmrQmH.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

Откройте SmartGit и перейдите в нужное место, затем:

![](https://i.imgur.com/C3JBYR6.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

Щелкните правой кнопкой мыши:

![](https://i.imgur.com/kIYnm16.png)

</p>
</details>

<hr>

Затем мы введем команду для клонирования **нашего** удалённого репозитория - не репозитория `space-wizards/space-station-14`.
<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/3HzCnjm.png)
![](https://i.imgur.com/a7vhKcC.png)


</p>
</details>  

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/YyJm5fx.png)


</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/Xn4AQLf.png)

Затем переключитесь на папку вашего репозитория, используя:
``cd space-station-14`` 

(Это может отличаться, если вы клонировали другой форк, но почти всегда это имя совпадает с именем репозитория)

Каждая команда в Git выглядит примерно так - `git` и затем ключевое слово `add`, `commit`, `pull` и т.д.

</p>
</details>

<hr>

После этого у вас будет локальный репозиторий, который теперь можно изменять! Однако вам еще предстоит выполнить некоторые настройки.

### 2.3 Боль с сабмодулями

**Обратите на это внимание!** Если вы не сделаете этого, то при попытке создать игру вы получите множество странных ошибок.

В Space Station 14 есть *множество* субмодулей - в первую очередь, наш движок RobustToolbox. Субмодули - это просто репозитории внутри репозитория, и их нужно обновлять вручную. Или нет?

У нас есть автоматическая программа обновления подмодулей, так что вам не нужно постоянно запускать `git submodule update --init --recursive` (команда для ручного обновления подмодулей).

Запустите `RUN_THIS.py` внутри репозитория, который вы скачали, с помощью Python(ВЫ же установили Python как я просил в начале этого гайда?). Желательно также из терминала введите `python RUN_THIS.py` или `python3 RUN_THIS.py`. Это должно занять несколько секунд, так что если все мгновенно прекратится, вы, вероятно, не используете Python 3.7+ или что-то в этом роде.

Если вы работаете под Windows и при попытке выполнить приведенную выше комбинацию действий получаете перенаправление в Microsoft Store или сообщение в терминале о том, что Python не установлен, вам нужно отключить ярлык Microsoft, который может вызывать эту проблему. Это можно сделать, найдя в поиске Windows пункт `Manage App Execution Aliases` и отключив две ссылки Python.

Если вы все же хотите модифицировать движок напрямую или обновлять субмодуль вручную (автообновление иногда доставляет неудобства), создайте файл DISABLE_SUBMODULE_AUTOUPDATE в директории BuildChecker/.

Если вам по какой-то причине понадобится вручную обновить RobustToolbox, вы можете использовать `cd RobustToolbox; git checkout v0.4.87` (замените `v0.4.87` на нужную вам версию RobustToolbox), а затем вы можете использовать `cd..\`, чтобы вернуться в репозиторий SS14. Это также пример использования `cd` для навигации по файлам, не выходя из командной строки.

## 3. Настройка удалённых репозиториев
Когда вы клонировали удалённый репозиторий, в ваш локальный репозиторий автоматически был добавлен **ремоут**. **Ремоуты** - это именованные URL-адреса удалённых репозиториев, которые Git отслеживает, чтобы вы могли делать такие вещи, как скачивать (pull) новые изменения в коде или загружать (push) код в ваш форкнутый репозиторий. 

В этом случае автоматически добавляемый удалённый репозиторий называется `origin` и указывает на `https://github.com/[имя пользователя-здесь]/space-station-14` (или как вы назвали удаленное хранилище).

Одна проблема: у нас нигде нет ссылки на оригинальный удаленный репозиторий `space-wizards/space-station-14`! Как же мы сможем обновить наш локальный репозиторий без неё? Поэтому давайте убедимся, что мы перешли в папку нашего локального репозитория, и добавим новый ремоут:

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/yANaYWI.png)
![](https://i.imgur.com/cjbhMEN.png)


</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/LXCpgVo.png)
![](https://i.imgur.com/ZHIHPJC.png)


</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/00ETpii.png)

</p>
</details>

<hr>

Все, что это делает, - добавляет новый удаленый репозиторий с именем `upstream`, который указывает на исходный репозиторий `space-wizards/space-station-14`. Теперь мы можем получать обновления из основного репозитория, когда захотим! (о том, как это сделать, читайте ниже). 

Принято называть удалённый репозиторий, указывающее на исходный репозиторий, `upstream`, но технически вы можете называть его как угодно. Однако я буду ссылаться на него как на «upstream», и это терминология, которую также используют руководства Git.

**Дополнение для разработчиков форков:** Если репозиторий, в который вы хотите внести вклад, настроен как прямой форк (IE: GitHub показывает метку «forked from» под именем репозитория), то вам дополнительно нужно добавить этот форк в качестве удаленного (но если форк не настроен таким образом, вы можете проигнорировать это). Вы можете сделать это аналогично тому, как вы добавили upstream в качестве remote (просто используйте ссылку на GitHub форка в качестве URL remote), но не забудьте заменить имя remote `upstream` на любое имя, которое вы считаете подходящим. Для этого ваш собственный форк не обязательно должен быть форком форка; важно лишь, чтобы история коммитов в отдельных ветках, которые вы отправляете на свой собственный удалённый ресурс, совпадала с историей коммитов того, куда вы собираетесь добавлять свои изменения.

```admonish warning title="Перед тем как приступить к работе над своим первым PR в репозитории space-wizards"
Убедитесь, что вы прочитали [Freezes & Restrictions](https://github.com/space-wizards/space-station-14/issues/8524) и удостоверились, что ваша идея не попадает под заморозку, или что для вашего PR требуется какое-то предварительное условие. 
```

## 4. Ветвление и коммиты

Ветви и коммиты - две самые важные концепции в Git, и большая часть вашей работы будет вращаться вокруг них.

### 4.1 Что такое этот ваш коммит?


Как я уже говорил, **коммиты** - это просто упакованные изменения в коде. Как разработчик, вы выбираете, какие изменения войдут в коммит и когда их фиксировать.

Коммиты имеют автора, временную метку создания, сообщение и некоторые изменения кода. У них также есть длинный «хэш коммита», уникальный идентификатор, используемый для ссылки на разные коммиты.

Коммиты - это то, как строится история. Вы можете просмотреть историю каждого коммита, сделанного в репозитории SS14 с самого начала, что очень здорово:

![](https://i.imgur.com/HQDdw6h.png)

(выполняется с помощью `git log --reverse`)

### 4.2 Что такое это ваша ветка(бранч)?

**Ветки**(в русском сообществе их называют бранчи!) очень, очень важны. По сути, это просто список изменений в коде (коммитов). По умолчанию используется бранч 'master', и все наши серверы используют эту ветку для компиляции кода. 

Вы практически всегда находитесь "в бранче", когда работаете с кодом, и вы можете легко переключать ветку, в которой работаете.
Как правило, ветки называются по имени того, над чем вы собираетесь в них работать, но на самом деле не имеет значения, как они называются.

Вы можете создавать столько веток, сколько захотите. Когда вы создаете ветку, она «отходит»  (нифига себе, правда?) от текущей ветки, на которой вы находитесь, и становится полностью независимой, в которую вы можете добавлять коммиты. 

![](https://i.imgur.com/ByMugxu.png=500x300)

На этой диаграмме каждый маленький узел - это отдельный коммит, а каждый цвет - отдельная ветвь.

#### Объединение веток

Ветви важны, потому что они могут быть **мерджнуты** вместе. Именно так функции интегрируются в основную ветку `master`. **Слияние** означает «взять специальные коммиты из этой ветки и применить их к другой ветке».  Вы можете объединить две любые ветки.

Иногда это не проходит гладко, потому что обе ветки изменяют одну и ту же часть файла противоречивыми способами, и в этом случае вы получите **мердж конфликт** - подробнее об этом в дополнениях.

Pull Requests(в русском сообществе их обычно называют ПРы) от GitHub на самом деле является «запросом на мердж» - вы говорите, что хотите объединить коммиты в вашей ветке с другой веткой, обычно `master`. Подробнее об этом позже.
ПРы очень хорошо отображают всю эту информацию:

![](https://i.imgur.com/YAOWX5R.png)
![](https://i.imgur.com/nWWy3J4.png)

В этом пулл реквесте Swept начал с создания новой ветки. Поскольку теперь у него была свежая ветка, свободная от помех, он начал работать над функцией и создавал коммиты для «сохранения прогресса», когда считал это необходимым. Эти коммиты добавлялись в ветку последовательно, и вы можете видеть эволюцию ветки по мере написания кода. Подробнее о запросах на исправление мы поговорим позже.

#### Но почему я должен это все делать?

Технически, конечно, вы можете просто сделать всю свою работу в ветке `master` и отправлять запросы оттуда. Но создание разных веток позволяет легко понять, где вы находитесь, сколько изменений вы внесли, и дает возможность работать над несколькими функциями одновременно.

Также мы закроем ваш PR, если он будет из вашей ветки `master` (это может легко привести к проблемам), так что не делайте этого.

### 4.3 Создание и работа с ветками

Создавать ветки довольно просто. Давайте создадим новую ветку под названием `smeshnoye-izmenenie`:

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/OGkblCk.png)
![](https://i.imgur.com/ZPfzFcm.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/pK1oyfz.png)
![](https://i.imgur.com/5MZ6Ocv.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/kOc9rfe.png)

Вы можете заметить, что название в скобках (master) изменился на (funny-feature)! Невероятно!

`-b` в `git checkout` здесь означает «проверить эту ветку, и создать её, если она не существует».

</p>
</details>

<hr>

Теперь вы можете свободно работать с этой веткой по своему усмотрению, не боясь испортить важную мастер-ветку.

Переключаться между ветками довольно просто: когда вы это делаете, ваши локальные файлы и папки будут изменены в соответствии с веткой, поэтому Git будет кричать на вас(и я тоже), если у вас есть локальные изменения, а вы пытаетесь сменить ветку.

Меняем ветку:

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/UThKrCK.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/fzC1pVm.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/DqWEdY5.png)

</p>
</details>

<hr>

Затем внесите любые локальные изменения! Это не имеет значения. Создайте новый файл, удалите всё, измените одну строку в файле и т. д. Это не повлияет на вашу `мастерскую` ветку, потому что теперь это земля `funny-feature`!

### 4.4 Внесение и сохранение изменений в вашей ветке

И еще один важный момент: прежде чем `коммитить` свои изменения, вы должны `добавить` их в **staging**. Это означает, что вы указываете, какие файлы вы хотите коммитнуть. Это полезно, потому что вы *почти никогда* не захотите коммитить изменения сабмодулей, поэтому вы избежите этого, не добавляя их в staging. 

Как уже говорилось, коммиты всегда сопровождаются сообщением, которое представляет собой краткое, императивное описание того, что было сделано в этом коммите. Или вы можете быть чадом и называть каждый коммит «123», решать вам.

Если вы хотите посмотреть, что вы изменили в данный момент и что находится в staging, это довольно просто:

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/xmZKKWJ.png)

TortoiseGit также показывает измененные файлы/папки (красный значок в правом нижнем углу) в проводнике Windows, что очень приятно и это почему я установил его в первую очередь.

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/ROsurs1.png)

Это при условии, что вы установили SmartGit с опцией, при которой в главном окне отображаются диффы и статус. Если вы этого не сделали, я не знаю, где это находится.

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/UeMjAHj.png)

</p>
</details>

<hr>

Теперь, когда вы убедились, что все эти изменения выглядят хорошо, мы добавим их в staging и коммитнем (некоторые графические интерфейсы Git делают это в один шаг).

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/ltIASro.png)
![](https://i.imgur.com/BIa9r6c.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/RYUL7u3.png)
![](https://i.imgur.com/Du7HqRV.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/mpKk5L1.png)

</p>
</details>

<hr>

Ух ты, мы зафиксировали наши изменения в ветке! Теперь, когда они зафиксированы, они навсегда остаются в истории ветки (вроде как). Теперь мы можем сделать множество вещей: мерджнуть нашу `funny-feature` в нашу локальную ветку `master` (если мы хотим, по какой-то причине), загрузить (push) нашу ветку `funny-feature` в наш удалённый репозиторий или полностью удалить ветку (среди прочего). Сейчас мы выберем push и сделаем pull request.

## 5. Делаем Pull Request

**Pull request** - это специфическая для GitHub вещь. Он означает, что вы хотите, чтобы кодовая база объединила ваши изменения в одной из ваших веток в одну из xe;b[] веток - как правило, в свою `master` ветку. Прежде чем мы сможем это сделать, наш удаленный репозиторий GitHub (origin) должен знать о красивых ветках и коммитах, которые мы создали локально, поэтому мы загружаем или **пушим**(push, толкаем) эти изменения на удаленный репозиторий.

### 5.1 Пушим коммиты

Теперь, когда мы коммитнули наши изменения, их очень просто пушнуть. Имейте в виду, что при использовании этих команд Git, вероятно, запросит ваши учетные данные GitHub, чтобы убедиться, что вам разрешено отправлять изменения на этот ремоут.

При пуше изменений мы указываем *удаленный* репозиторий, в который мы отправляем изменения, и *локальную* ветку, в которую мы отправляем изменения. Достаточно просто.

Пушим нашу ветку в удаленный репозиторий (origin):

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/bWS5Kdk.png)
![](https://i.imgur.com/Irv1e5k.png)

 «Push all branches» делает то, что написано в его названии. Может быть полезным.

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/s82VnNn.png)
![](https://i.imgur.com/VP8PuCq.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/7FJqzkL.png)

</p>
</details>

### 5.2 Создание Pull Request'а

А теперь самое интересное. Сейчас мы пойдем на GitHub и сделаем pull request для нашей забавной функции.

![](https://i.imgur.com/YNmEMtG.png)

Добавьте описание, красивое название, несколько скриншотов, и, надейтесь, что он будет мерджнут.

## 6. Обновляем наш репозиторий

Возможно, прошло уже много времени, неделя или две, с момента вашего последнего ПРа, и вы хотите сделать еще один. Прежде чем что-то делать, вам нужно загрузить (**pull**) изменения кода из основного репозитория SS14 в свой локальный репозиторий. Если вы этого не сделаете, у вас будет устаревший код, а ваши локальные изменения могут не соответствовать тому, как игра будет работать на самом деле - вы даже можете получить **мердж конфликт**, когда попытаетесь сделать ПР.

Существует два способа обновления репозитория. Оба способа предполагают, что вы правильно настроили удаленный `upstream` - если это не так, вернитесь к предыдущему пункту руководства. И, конечно, если вы разрабатываете для форка, то вам нужно заменить `upstream` на то, как вы назвали репозиторий downstream в шаге 4, чтобы убедиться, что вы работаете с файлами downstream, а не upstream. Убедитесь, что вы *всегда* проходите процесс обновления при переключении между вкладом в форк и вкладом в upstream, иначе вы неизбежно окажетесь либо в PR всей истории downstream в upstream, либо сделаете PR в downstream, которые немедленно вступят в конфликт.

Первый метод, **fetch+merge**, дает вам больше контроля, но может быть запутанным. Второй метод, **pull**, прост и легок, но не дает вам большого контроля. Однако, как правило, pull - это все, что вам нужно.

### 6.1 Метод fetch + merge

**Fetching** означает загрузку новых веток и коммитов из удалённого репозитория, но пока ничего с ними не делаем (локально ничего не изменится). После получения изменений из удаленного `upstream` (основного репозитория SS14) мы объединим их с нашей локальной веткой `master`.

Когда вы качаете удалённый репозиторий, он загружает эти ветки в ваш локальный репозиторий и добавляет к ним имя удалённой ветки и слеш. Таким образом, когда вы получаете `upstream`, он создаст ветку под названием `upstream/master`. В качестве бонуса вы можете проверить эту удаленную ветку напрямую, если захотите, и даже создать на ее основе локальную ветку, что особенно полезно, если вы работаете не только с upstream.

Сначала давайте фетчнем `upstream`. Это займет немного времени.

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/3cWun8b.png)
![](https://i.imgur.com/XGgXRY0.png)

Убедитесь, что вы выбрали `upstream`, а не origin!

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/CNFFJJ8.png)

Я думаю, что smartgit берет данные со всех ремоутов, когда вы нажимаете вот это?????.

Если это не так, и он просто берет из origin, перейдите в левый нижний угол и сделайте следующее:

![](https://i.imgur.com/8rF0tz5.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/aJvW9PX.png)

Здесь ничего не произошло, потому что я только что выполнил фетч и это займет некоторое время.

</p>
</details>

<hr>

Теперь мы мерджнем изменения, которые мы только что загрузили, в нашу ветку `master`. Здесь не обязательно мерджить в master; вы можете мерджнуть и в другую ветку. Если вы просто хотите «быстро» обновить одну из ваших веток, чтобы убедиться, что ваш PR обновлён, вы можете мерджнуть коммиты и в эту ветку.

Проверьте ветку в которую вы хотите мерджнуть ПР и затем,

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/8lUaEFt.png)
![](https://i.imgur.com/7BvBPYY.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/n8cc2DN.png)
![](https://i.imgur.com/aRSawAo.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/H2L8pOp.png)

Вы также можете `git merge upstream/master [ветка куда мерджнуть]

</p>
</details>

### 6.2 Метод Pull'а

**Pulling** означает **фетчинг** (загрузку) новых веток и коммитов из удаленного репозитория, а затем их мердж в вашу ветку. Пуллинг часто проще, потому что в Git есть хорошая система для автоматического определения того, из какого удалённого репозитория вы хотите получить информацию (но она не всегда работает хорошо). 

Пуллить обычно проще и намного легче.

Мы сделаем **pull** из нашего удаленного `upstream` (основного репо SS14) и скажем ему слиться с нашей локальной `master` веткой.

Сначала `checkout` `master` ветку. Мы уже рассказывали об этом ранее. Затем,

<details><summary>TortoiseGit</summary>
<p>

![](https://i.imgur.com/XMUt6cv.png)
![](https://i.imgur.com/NHVlZ4W.png)

</p>
</details>

<details><summary>SmartGit</summary>
<p>

![](https://i.imgur.com/ANqpcph.png)
![](https://i.imgur.com/kvv058A.png)
![](https://i.imgur.com/k0scDB8.png)

</p>
</details>

<details><summary>Git Bash</summary>
<p>

![](https://i.imgur.com/OfHut9Y.png)

</p>
</details>

<hr>

Если оба метода прошли успешно, значит, вы успешно обновили мастер-ветку (или ту ветку, которую вы выбрали для обновления)! Делайте это регулярно и всегда перед началом работы над новой веткой.

# Дополнения

## 1. Что нужно иметь в виду

Вы более или менее изучили рабочий процесс разработки функций для SS14 с точки зрения Git, но вот некоторые вещи, которые я бы хотел вбить вам в голову:
- При создании новой штуки, *всегда всегда* создавайте новую ветку от `master`, прежде чем коммитить что-либо. Если вы случайно закоммитите изменения физики в ветку с велосипедным клаксоном, вам не поздоровится, но это поправимо (см. Ёбанный Git!!!» выше).
- **Никогда, никогда не коммитьте в RobustToolbox или любые сабмодули вроде Lidgren.Network**, если вы не знаете, что делаете. В локальном репозитории верхнего уровня эти сабмодули считаются «файлами», поэтому их легко случайно закоммитить. Не делайте этого. О том, как исправить свои ошибки, если это произошло, читайте ниже.
- Если вам нужна дополнительная помощь с Git, не стесняйтесь спрашивать в [SS14 Discord](https://discord.gg/ss14) в канал #разработка

## 2. Быстрый пример рабочего процесса

Чтобы все уложилось в голове и всё подытожить, вот пример рабочего процесса по созданию нескольких Пулл Реквестов с помощью команд Git Bash.

```python
git checkout master # Прежде чем мы создадим новую ветку, мы должны быть на master.
git fetch upstream # Мы получим все новые изменения из репозитория SS14...
git merge upstream/master # ...и объединим их в нашу ветку master.

git checkout -b my-new-feature # Создаём новую ветку для нашей фичи.
...после локальных изменений кода...
git add -A # Добавляем все наши локальные изменения в staging
git commit -m «Fix spaghetti explosions» # Коммитим их
git push origin my-new-feature # и отправляем их на наш удалённый репозиторий

# Теперь я хочу поработать над другим ПРом.

git checkout master

# Прошло не так много времени, и ничего важного не было мерджнуто,
# поэтому я не буду фетчить и мерджить изменения снова - просто новая ветка.

git checkout -b another-feature
...после локальных изменений кода...
git add -A
git commit -m «Удаляет ядерных оперативников»

# Я коммитнул изменение, но потом понял, что мой коммит был совершенно неправильным 
# и я займусь этим позже.

git revert HEAD
git checkout master

...неделю спустя...

# Было мерджнуто много нового, так что давайте обновим нашу ветку.

git fetch upstream
git merge upstream/master master
git checkout another-feature
git merge master

# Теперь внесём изменения и снова пушнем, на этот раз корректно.

...локальные изменения позже...
git add -A
git commit -m «Добавляет игровой режим Highlander»
git push origin another-feature

# Мы сделали оба PR, оба были объединены, так что на этом мы закончили

git checkout master
git branch -d my-new-feature # Удаляем обе старые ветки
git branch -d another-feature

```

# Глоссарий: Внутренние механизмы Git

Для справки, вот небольшой глоссарий понятий и терминов Git, объясняющий их более подробно и в одном месте.

- **'Ветки'**(Branch) это последовательность коммитов (история изменения состояния репозитория). Каждый коммит в ветке имеет «родителя» (parent commit) - коммит, на основе которого был получен текущий. В репозитории может быть несколько веток (в случаях, когда к одной версии репозитория применяется несколько независимых изменений).
- **'Репозиторий'** совокупность файлов, состояние которых отслеживается, и история их изменений. По факту, репозиторий — это проект, над которым ведется работа, и все изменения в этом проекте. Для отслеживания состояния файла его необходимо добавить в репозиторий, репозитории живут на сайтах по типу [GitHub](https://github.com/space-wizards/space-station-14).
- **'Ремоуты'** это имена и ссылки на удаленные репозитории, которые может использовать ваш локальный репозиторий.
- **'Сабмодули'** это репозитории, которые находятся внутри другого репозитория.
- **'Форки'** это репозитории, которые основаны на другом репозитории. Если вы собираетесь сделать ПР в репозиторий SS14, вам нужно сначала его форкнуть.
- **"Рабочее дерево"**(Working tree) - это все файлы, папки и прочее, что есть в репозитории.
- **'Staging'** означает добавление (с помощью `git add`) изменений из вашего рабочего дерева в «staging area», где над ними могут быть произведены некоторые действия.
- **'Коммиты'** это снимки рабочего дерева репозитория в определённый момент времени. По сути, это точка сохранения. Коммит» - это просто список файлов, которые были изменены с момента последнего коммита, а изменения, которые "коммитнули", - это изменения, которые вы "стейджнули"
- **'Чекаут'**(Checkout) - это акт переключения на другую ветку, чтобы вы могли работать с ней или просматривать её изменения локально.
- **'Мерджинг'** это акт интеграции изменений из одной ветки в другую ветку.
- **'Мердж конфликты'** возникают, когда интеграция изменений из одной ветки в другую не может быть выполнена автоматически, потому что обе ветки изменяют одну и ту же область файла или их изменения взаимоисключают друг друга каким-либо другим способом.
- **'Фетчинг'**(Fetching) означает получить ветки и коммиты удаленного репозитория, но на самом деле... ничего с ними пока не делать. Они просто будут обновлены, если вы захотите проверить или мерджнуть их позже.. 
- **'Пуллинг'**(Pulling) это акт интеграции изменений из ветки удаленного репозитория в вашу локальную ветку.
- **'Пулл Реквесты'**(Pull Request) это специфическое для GitHub действие, позволяющее запросить слияние вашей локальной ветки и всех ее изменений с веткой другого репозитория.
- **'Пушинг'**(Pushing) это акт интеграции ваших локальных изменений в удаленный репозиторий.

Существует гораздо больше команд и концепций, чем эта, но это все, что вам действительно нужно знать для базовой разработки.

# Appendix A: Helpful tips and tricks

There's some stuff I didn't cover, but you'll almost inevitably have to do at some point. I'll cover these all **exclusively as git commands in Git Bash** quickly, but they're not too hard to figure out in the other programs (same keywords, just look for those). I recommend using their specific guides because I don't know TortoiseGit / SmartGit / GitKraken / Github Desktop well enough to help you with more advanced stuff.

One note since it comes up a lot here: **`HEAD` is a fancy name for the commit that you're currently on**. Nothing more than that. Branches are also technically fancy names for commits, but you don't need to know that yet.

A lot of these can be found probably more eloquently in Oh Shit, Git?! (see resources above)


## Resolving merge conflicts

*WIP i'll write a better guide for this later because it's important*

A nasty little maintainer has told you to 'resolve conflicts' or your PR 'wont be merged'. What an asshole! Thankfully, it's not too hard.

First, you're going to want to update your local `master branch`. See above for how to do that.

When you run `git merge master [local branch]`, it'll either do it cleanly (woohoo) or tell you you have to resolve conflicts (wahhhh). 

All you need to do to resolve conflicts manually is go into the files that are conflicting, remove all the `>>>>HEAD` and `===== <<<<master` nonsense (just notates where the changes originated) and then edit the file so that it properly integrates both sets of changes. Sometimes this is easy, sometimes it's hard. If it's hard, you probably know what you're doing. After that, just `git commit`.

Atlassian has a really good guide for this [here](https://www.atlassian.com/git/tutorials/using-branches/merge-conflicts)

## Checking history

`git log --oneline` is your friend. It shows short commit hashes (unique IDs for commits), their messages, and their branches and tags.

## Getting rid of local changes

You might have accidentally made changes you didn't want to, and you don't want to bother with making an entirely new branch or something--but you haven't committed those changes yet.

```
git reset --hard HEAD
```

This just means 'change the working tree to the current commit, before any local changes. Or else.' **You can't retrieve those local changes if you do this, so be wary.**

## Unstaging changes

Ah shit, I just staged RobustToolbox by accident. No fear!

```
git reset HEAD [file]
```

Alternatively, to unstage everything:

```
git reset HEAD
```

## Reverting a commit you made

Oh shit, your xenomorph erotica made its way into a commit/you accidentally committed a submodule! What now? Well, there's two solutions:

```
git revert HEAD
```

This makes a new commit undoing the current commit, and then commits it. Hehe commit. 

If you want to undo a different commit, you can check its hash in `git log --oneline` and then call `git revert [commit hash]`. Git has a more robust system for doing this; you can do `git revert HEAD~1` to undo the commit before your current one or `git revert HEAD~2` to revert the one before that. The `~1` just means '1 commit before HEAD'.

Alternatively,

```
git reset --hard HEAD~1
```

**I don't recommend doing this unless you're fully aware of what you're doing.**

For when you REALLY don't want anyone to know about that xenomorph erotica you just made. This method rewrites history, so it isn't the best for a collaborative environment. If you do this, you'll need to force push (`git push origin [branch] --force`) or else it won't work. Force pushing can be dangerous, so again, be sure you know what you're doing.


## Checking out a PR's changes locally

Ok, this one is a little difficult. There's a couple ways to do this:

### Github CLI

Install github's fancy CLI and do this:

```
gh pr checkout [pr number]
```

Neat.

### Changing .git/config

Go into your .git folder (hidden by default--may need to enable showing hidden folders in Windows), and open up the 'config' file. There should be a bit that looks something like:

```
[remote "upstream"]
	url = https://github.com/space-wizards/space-station-14
	fetch = +refs/heads/*:refs/remotes/upstream/*
```

Add a line to this that reads `fetch = +refs/pull/*/head:refs/remotes/upstream/pr/*`, so that section should now look like:

```
[remote "upstream"]
        url = https://github.com/space-wizards/space-station-14
        fetch = +refs/heads/*:refs/remotes/upstream/*
        fetch = +refs/pull/*/head:refs/remotes/upstream/pr/*
```

Now, `git fetch upstream`. This method is great if you're a maintainer, but it also.. fetches every branch that's still up from every PR that's been opened, so not fantastic if you just wanted one thing. From here, you can `git checkout upstream/pr/[pr number]` to check out their branch. This is basically what GitHub CLI does but less sophisticated.

### Adding a new remote

This method kinda sucks because it takes a while but if you want to check out someone else's fork of the game and their branches it's pretty nice.

Not actually that hard but its confusing if you don't know Git very well. Set up a remote to the user's remote repository, fetch their branches, and then checkout their branch:

```
git remote add [username] https://github.com/[username]/space-station-14
git fetch [username]
git checkout [username]/[branch name]
```

This also lets you make PRs to their remote branch, if you so desired.
